<!DOCTYPE html>
<html lang="en">
<head th:replace="~{fragments/header :: head}" th:with="pageTitle=${language != null and language == 'en' ? 'Home' : '首页'}">

    <style type="text/tailwindcss">
        @layer utilities {
            .glass-effect {
                backdrop-filter: blur(8px);
                background-color: rgba(75, 85, 99, 0.15);
            }

            .text-balance {
                text-wrap: balance;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col" style="margin: 0; padding: 0; overflow: hidden;">

<main class="flex-grow w-full h-screen">
    <!-- 主容器 -->
    <div class="relative w-full h-screen flex flex-col">
        <!-- 画布容器 -->
        <canvas id="geometryCanvas" class="absolute inset-0 w-full h-full"></canvas>

        <!-- 整块玻璃就是按钮 -->
        <div onclick="window.location.href='/quotes'"
             style="background-color: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-primary);"
             class="rounded-lg px-4 py-3 fixed bottom-4 left-1/2 -translate-x-1/2 text-sm sm:px-7 sm:py-5 sm:text-lg text-base cursor-pointer z-50 transition-colors duration-300 hover:shadow-lg backdrop-blur-sm">
            <i class="fa fa-arrow-right"></i> <span th:text="${translationService.getStaticText('welcome_tour', language)}">欢迎游览</span>
        </div>


        <script>
            // 获取画布和上下文
            const canvas = document.getElementById('geometryCanvas');
            const ctx = canvas.getContext('2d');

            // 设置画布尺寸
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }

            resizeCanvas();
            window.addEventListener('resize', () => {
                resizeCanvas();
                if (typeof updateResponsive === 'function') {
                    updateResponsive();
                }
            });

            // 获取当前主题的线条颜色
            function getThemeLineColors() {
                // 检查是否是midnight主题
                if (document.documentElement.classList.contains('theme-midnight')) {
                    // midnight主题使用更深的灰色，不要太白
                    return [
                        '#6B7280', // 中灰色
                        '#9CA3AF', // 浅灰色
                        '#4B5563', // 深灰色
                        '#6B7280'  // 中灰色
                    ];
                }
                
                const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();
                const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--color-secondary').trim();
                const textPrimary = getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim();
                const textSecondary = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();
                
                return [
                    primaryColor || '#9CA3AF',
                    secondaryColor || '#D1D5DB',
                    textPrimary || '#F3F4F6',
                    textSecondary || '#E5E7EB'
                ];
            }

            // 几何体配置 - 调整了线条宽度和颜色方案
            const config = {
                rotationSpeed: 0.008,
                isRotating: true,
                showTrails: false,
                trailOpacity: 0.05,
                lineWidth: 1.5,
                colorScheme: getThemeLineColors() // 使用主题颜色
            };
            // 是否为桌面端
            function isDesktop() {
                return window.innerWidth >= 768;
            }
            // 根据屏幕宽度获取焦距值
            function getFocalLength() {
                // 小于768px视为移动设备，使用200焦距
                // 大于等于768px视为桌面设备，使用400焦距
                return window.innerWidth < 768 ? 200 : 500;
            }
            // 3D点类
            class Point3D {
                constructor(x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.originalX = x;
                    this.originalY = y;
                    this.originalZ = z;
                }

                // 旋转方法
                rotateX(angle) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const y = this.y * cos - this.z * sin;
                    const z = this.y * sin + this.z * cos;
                    this.y = y;
                    this.z = z;
                }

                rotateY(angle) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const x = this.x * cos - this.z * sin;
                    const z = this.x * sin + this.z * cos;
                    this.x = x;
                    this.z = z;
                }

                rotateZ(angle) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const x = this.x * cos - this.y * sin;
                    const y = this.x * sin + this.y * cos;
                    this.x = x;
                    this.y = y;
                }

                // 投影到2D
                project() {
                    const focalLength = getFocalLength();
                    const scale = focalLength / (focalLength + this.z);
                    const x = this.x * scale + canvas.width / 2;
                    const y = this.y * scale + canvas.height / 2;
                    return { x, y, scale };
                }

            }

            // 几何体类
            class Geometry {
                constructor() {
                    this.points = [];
                    this.connections = [];
                    this.rotationX = 0;
                    this.rotationY = 0;
                    this.rotationZ = 0;
                    this.size = 0;
                    this.initialize();
                }

                // 初始化几何体 - 只创建六面体
                initialize() {
                    // 移动端保持 0.1，桌面端稍微更小一些
                    const sizeRatio = isDesktop() ? 0.08 : 0.1;
                    this.size = Math.min(canvas.width, canvas.height) * sizeRatio;
                    this.points = [];
                    this.connections = [];

                    this.createCube(); // 只创建六面体
                }

                // 创建六面体（立方体）
                createCube() {
                    const halfSize = this.size;

                    // 立方体的8个顶点
                    this.points.push(new Point3D(-halfSize, -halfSize, -halfSize)); // 0
                    this.points.push(new Point3D(halfSize, -halfSize, -halfSize));  // 1
                    this.points.push(new Point3D(halfSize, halfSize, -halfSize));   // 2
                    this.points.push(new Point3D(-halfSize, halfSize, -halfSize));  // 3
                    this.points.push(new Point3D(-halfSize, -halfSize, halfSize));  // 4
                    this.points.push(new Point3D(halfSize, -halfSize, halfSize));   // 5
                    this.points.push(new Point3D(halfSize, halfSize, halfSize));    // 6
                    this.points.push(new Point3D(-halfSize, halfSize, halfSize));   // 7

                    // 立方体的12条边
                    // 前面
                    this.connections.push([0, 1]);
                    this.connections.push([1, 2]);
                    this.connections.push([2, 3]);
                    this.connections.push([3, 0]);

                    // 后面
                    this.connections.push([4, 5]);
                    this.connections.push([5, 6]);
                    this.connections.push([6, 7]);
                    this.connections.push([7, 4]);

                    // 连接前后
                    this.connections.push([0, 4]);
                    this.connections.push([1, 5]);
                    this.connections.push([2, 6]);
                    this.connections.push([3, 7]);
                }

                // 更新旋转
                update() {
                    if (!config.isRotating) return;

                    this.rotationX += config.rotationSpeed;
                    this.rotationY += config.rotationSpeed * 0.7;
                    this.rotationZ += config.rotationSpeed * 0.3;

                    // 应用旋转到所有点
                    this.points.forEach(point => {
                        // 重置到原始位置
                        point.x = point.originalX;
                        point.y = point.originalY;
                        point.z = point.originalZ;

                        // 应用旋转
                        point.rotateX(this.rotationX);
                        point.rotateY(this.rotationY);
                        point.rotateZ(this.rotationZ);
                    });
                }

                // 绘制几何体
                draw() {
                    // 绘制连接线
                    ctx.lineWidth = config.lineWidth;

                    // 使用统一的主色调（第一个颜色）
                    const baseColor = config.colorScheme[0];
                    const alpha = 0.8;

                    // 转换为RGBA
                    const hexToRgba = (hex, alpha) => {
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    };

                    ctx.strokeStyle = hexToRgba(baseColor, alpha);

                    this.connections.forEach(([aIndex, bIndex], i) => {
                        const a = this.points[aIndex];
                        const b = this.points[bIndex];

                        const projA = a.project();
                        const projB = b.project();

                        // 绘制线段
                        ctx.beginPath();
                        ctx.moveTo(projA.x, projA.y);
                        ctx.lineTo(projB.x, projB.y);
                        ctx.stroke();
                    });
                }
            }

            // 创建几何体实例
            let geometry = new Geometry();

            // 根据设备宽度更新线条粗细与几何体尺寸
            function updateResponsive() {
                // 移动端保持不变，桌面端线条更粗
                config.lineWidth = isDesktop() ? 2.5 : 1.5;
                geometry.initialize();
            }
            // 初始化一次
            updateResponsive();

            // 获取当前主题的背景色
            function getThemeBackgroundColor() {
                const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim();
                return bgColor || '#FFFFFF';
            }

            // 动画循环
            function animate() {
                // 使用主题背景色
                const bgColor = getThemeBackgroundColor();
                
                // 清除画布 - 带轨迹效果
                if (config.showTrails) {
                    // 将主题背景色转换为半透明
                    ctx.fillStyle = bgColor.replace(')', `, ${config.trailOpacity})`).replace('rgb', 'rgba');
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // 更新并绘制几何体
                geometry.update();
                geometry.draw();

                requestAnimationFrame(animate);
            }

            // 启动动画
            animate();

            // 鼠标交互 - 拖动旋转
            let isDragging = false;
            let lastMouseX, lastMouseY;
            let initialRotationX, initialRotationY;

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                initialRotationX = geometry.rotationX;
                initialRotationY = geometry.rotationY;
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;

                geometry.rotationY = initialRotationY + deltaX * 0.005;
                geometry.rotationX = initialRotationX + deltaY * 0.005;
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // 触摸支持
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouseX = e.touches[0].clientX;
                    lastMouseY = e.touches[0].clientY;
                    initialRotationX = geometry.rotationX;
                    initialRotationY = geometry.rotationY;
                    e.preventDefault();
                }
            });

            window.addEventListener('touchmove', (e) => {
                if (!isDragging || e.touches.length !== 1) return;

                const deltaX = e.touches[0].clientX - lastMouseX;
                const deltaY = e.touches[0].clientY - lastMouseY;

                geometry.rotationY = initialRotationY + deltaX * 0.005;
                geometry.rotationX = initialRotationX + deltaY * 0.005;
                e.preventDefault();
            });

            window.addEventListener('touchend', () => {
                isDragging = false;
            });
        </script>
        
        <!-- 点赞按钮功能 -->
        <script th:src="@{/js/like-button-component.js}"></script>
    </div>
</main>

<!-- 全局主题切换脚本 -->
<div th:replace="~{fragments/footer :: theme-script}"></div>

</body>
</html>